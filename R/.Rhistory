(is.data.frame(array) && nrow(array) == 0)) {
return(NA_character_)
}
if (!is.list(array)) {
return(NA_character_)
}
values <- vapply(array, function(x) {
result <- if (is.list(x)) x[[field_name]] %||% "" else ""
if (length(result) == 0) return("")
if (length(result) > 1) return(paste(result, collapse = " "))
return(as.character(result))
}, character(1))
# Filter out empty strings before joining
non_empty_values <- values[values != "" & !is.na(values)]
if (length(non_empty_values) == 0) {
return(NA_character_)
}
paste(non_empty_values, collapse = "; ")
}
# Helper function to safely extract nested fields
safe_extract <- function(obj, ...) {
path <- list(...)
result <- obj
for (key in path) {
if (!is.list(result) || is.null(result[[key]])) {
return(NA_character_)
}
result <- result[[key]]
}
result %||% NA_character_
}
# Helper function to extract most recent date from potentially multiple date objects
extract_most_recent_date <- function(obj, date_field) {
if (is.null(obj)) {
return(NA_character_)
}
# If it's a single object (not an array)
if (is.list(obj) && !is.null(obj[[date_field]]) && !is.data.frame(obj)) {
return(obj[[date_field]] %||% NA_character_)
}
# If it's an array of objects or data frame
if (is.data.frame(obj) || (is.list(obj) && length(obj) > 0 && is.list(obj[[1]]))) {
dates <- if (is.data.frame(obj)) {
obj[[date_field]]
} else {
vapply(obj, function(x) x[[date_field]] %||% "", character(1))
}
# Filter out empty/NA dates and find most recent
valid_dates <- dates[!is.na(dates) & dates != ""]
if (length(valid_dates) == 0) {
return(NA_character_)
}
# Return the most recent date (assuming ISO format YYYY-MM-DD)
return(max(valid_dates))
}
return(NA_character_)
}
# Helper function to extract inspectionCategories as nested dataframe
extract_inspection_categories <- function(categories) {
if (is.null(categories) || length(categories) == 0) {
return(list(tibble(primary = character(0), code = character(0), name = character(0))))
}
if (!is.list(categories)) {
return(list(tibble(primary = character(0), code = character(0), name = character(0))))
}
# Extract each category into a row
category_rows <- lapply(categories, function(cat) {
if (!is.list(cat)) {
return(tibble(primary = NA_character_, code = NA_character_, name = NA_character_))
}
tibble(
primary = cat$primary %||% NA_character_,
code = cat$code %||% NA_character_,
name = cat$name %||% NA_character_
)
})
# Combine all rows into one dataframe
result_df <- do.call(rbind, category_rows)
# Return as a list containing the dataframe (for nested column)
list(result_df)
}
# Helper function to extract keyQuestionRatings as nested dataframe
extract_key_question_ratings <- function(ratings_obj) {
if (is.null(ratings_obj) || !is.list(ratings_obj)) {
return(list(tibble(name = character(0), rating = character(0), reportDate = character(0), reportLinkId = character(0))))
}
key_ratings <- ratings_obj$keyQuestionRatings
if (is.null(key_ratings) || length(key_ratings) == 0) {
return(list(tibble(name = character(0), rating = character(0), reportDate = character(0), reportLinkId = character(0))))
}
if (!is.list(key_ratings)) {
return(list(tibble(name = character(0), rating = character(0), reportDate = character(0), reportLinkId = character(0))))
}
# Extract each key question rating into a row
rating_rows <- lapply(key_ratings, function(kq) {
if (!is.list(kq)) {
return(tibble(name = NA_character_, rating = NA_character_, reportDate = NA_character_, reportLinkId = NA_character_))
}
tibble(
name = kq$name %||% NA_character_,
rating = kq$rating %||% NA_character_,
reportDate = kq$reportDate %||% NA_character_,
reportLinkId = kq$reportLinkId %||% NA_character_
)
})
# Combine all rows into one dataframe
result_df <- do.call(rbind, rating_rows)
# Return as a list containing the dataframe (for nested column)
list(result_df)
}
# Helper function to extract specific contact fields from regulatedActivities
extract_contact_field <- function(reg_activities, field_name) {
if (is.null(reg_activities) || length(reg_activities) == 0) {
return(NA_character_)
}
all_values <- c()
for (activity in reg_activities) {
if (!is.list(activity)) next
contacts <- activity$contacts %||% list()
if (length(contacts) == 0) next
for (contact in contacts) {
if (!is.list(contact)) next
value <- contact[[field_name]]
if (!is.null(value)) {
if (field_name == "personRoles" && is.list(value)) {
# Handle roles as an array
all_values <- c(all_values, paste(value, collapse = ", "))
} else {
all_values <- c(all_values, as.character(value))
}
}
}
}
if (length(all_values) == 0) {
return(NA_character_)
}
paste(all_values, collapse = "; ")
}
# Helper function to extract most recent report
extract_most_recent_report <- function(reports) {
if (is.null(reports) || length(reports) == 0) {
return(list(
linkId = NA_character_,
reportDate = NA_character_,
firstVisitDate = NA_character_,
reportUri = NA_character_,
reportType = NA_character_,
relatedDocuments = list()
))
}
if (!is.list(reports)) {
return(list(
linkId = NA_character_,
reportDate = NA_character_,
firstVisitDate = NA_character_,
reportUri = NA_character_,
reportType = NA_character_,
relatedDocuments = list()
))
}
# Find the most recent report by reportDate
report_dates <- vapply(reports, function(r) {
if (is.list(r) && !is.null(r$reportDate)) {
return(r$reportDate)
}
return("")
}, character(1))
# Filter out empty dates
valid_reports <- reports[report_dates != ""]
valid_dates <- report_dates[report_dates != ""]
if (length(valid_reports) == 0) {
return(list(
linkId = NA_character_,
reportDate = NA_character_,
firstVisitDate = NA_character_,
reportUri = NA_character_,
reportType = NA_character_,
relatedDocuments = list()
))
}
# Get the most recent report
most_recent_idx <- which.max(valid_dates)
most_recent_report <- valid_reports[[most_recent_idx]]
list(
linkId = most_recent_report$linkId %||% NA_character_,
reportDate = most_recent_report$reportDate %||% NA_character_,
firstVisitDate = most_recent_report$firstVisitDate %||% NA_character_,
reportUri = most_recent_report$reportUri %||% NA_character_,
reportType = most_recent_report$reportType %||% NA_character_,
relatedDocuments = most_recent_report$relatedDocuments %||% list()
)
}
# Helper function to extract relatedDocuments as nested dataframe
extract_related_documents <- function(related_docs) {
if (is.null(related_docs) || length(related_docs) == 0) {
return(list(tibble(relatedDocuments_documentUri = character(0), relatedDocuments_documentType = character(0))))
}
if (!is.list(related_docs)) {
return(list(tibble(relatedDocuments_documentUri = character(0), relatedDocuments_documentType = character(0))))
}
# Extract each related document into a row
doc_rows <- lapply(related_docs, function(doc) {
if (!is.list(doc)) {
return(tibble(relatedDocuments_documentUri = NA_character_, relatedDocuments_documentType = NA_character_))
}
tibble(
relatedDocuments_documentUri = doc$documentUri %||% NA_character_,
relatedDocuments_documentType = doc$documentType %||% NA_character_
)
})
# Combine all rows into one dataframe
result_df <- do.call(rbind, doc_rows)
# Return as a list containing the dataframe (for nested column)
list(result_df)
}
# Helper function to extract unpublishedReports firstVisitDate
extract_unpublished_reports_first_visit <- function(unpublished_reports) {
if (is.null(unpublished_reports) || length(unpublished_reports) == 0) {
return(NA_character_)
}
if (!is.list(unpublished_reports)) {
return(NA_character_)
}
first_visit_dates <- vapply(unpublished_reports, function(report) {
if (is.list(report) && !is.null(report$firstVisitDate)) {
return(report$firstVisitDate)
}
return("")
}, character(1))
# Filter out empty dates
valid_dates <- first_visit_dates[first_visit_dates != "" & !is.na(first_visit_dates)]
if (length(valid_dates) == 0) {
return(NA_character_)
}
paste(valid_dates, collapse = "; ")
}
# Helper function to extract provider inspection areas fields
extract_provider_inspection_field <- function(provider_areas, field_name) {
if (is.null(provider_areas) || length(provider_areas) == 0) {
return(NA_character_)
}
if (!is.list(provider_areas)) {
return(NA_character_)
}
all_values <- c()
for (area in provider_areas) {
if (!is.list(area)) next
if (field_name == "inspectionAreaId") {
# Extract inspection area ID
value <- area$inspectionAreaId
if (!is.null(value)) {
all_values <- c(all_values, as.character(value))
}
} else {
# Extract from reports within each area
reports <- area$reports %||% list()
if (length(reports) == 0) next
for (report in reports) {
if (!is.list(report)) next
# Extract the specific field from the report
value <- report[[field_name]]
if (!is.null(value)) {
all_values <- c(all_values, as.character(value))
}
}
}
}
if (length(all_values) == 0) {
return(NA_character_)
}
paste(all_values, collapse = "; ")
}
# Read JSON
x <- fromJSON(file, simplifyVector = TRUE)
# Get most recent report once for efficiency
most_recent_report <- extract_most_recent_report(x$reports)
# Build main tibble
tibble(
# Basic fields
locationId = x$locationId %||% NA_character_,
providerId = x$providerId %||% NA_character_,
organisationType = x$organisationType %||% NA_character_,
type = x$type %||% NA_character_,
name = x$name %||% NA_character_,
brandId = x$brandId %||% NA_character_,
brandName = x$brandName %||% NA_character_,
onspdCcgCode = x$onspdCcgCode %||% NA_character_,
onspdCcgName = x$onspdCcgName %||% NA_character_,
odsCcgCode = x$odsCcgCode %||% NA_character_,
odsCcgName = x$odsCcgName %||% NA_character_,
onspdIcbCode = x$onspdIcbCode %||% NA_character_,
onspdIcbName = x$onspdIcbName %||% NA_character_,
odsCode = x$odsCode %||% NA_character_,
registrationStatus = x$registrationStatus %||% NA_character_,
registrationDate = x$registrationDate %||% NA_character_,
deregistrationDate = x$deregistrationDate %||% NA_character_,
dormancy = x$dormancy %||% NA_character_,
dormancyStartDate = x$dormancyStartDate %||% NA_character_,
dormancyEndDate = x$dormancyEndDate %||% NA_character_,
alsoKnownAs = x$alsoKnownAs %||% NA_character_,
onspdLatitude = x$onspdLatitude %||% NA_real_,
onspdLongitude = x$onspdLongitude %||% NA_real_,
careHome = x$careHome %||% NA_character_,
inspectionDirectorate = x$inspectionDirectorate %||% NA_character_,
website = x$website %||% NA_character_,
postalAddressLine1 = x$postalAddressLine1 %||% NA_character_,
postalAddressLine2 = x$postalAddressLine2 %||% NA_character_,
postalAddressTownCity = x$postalAddressTownCity %||% NA_character_,
postalAddressCounty = x$postalAddressCounty %||% NA_character_,
region = x$region %||% NA_character_,
postalCode = x$postalCode %||% NA_character_,
uprn = x$uprn %||% NA_character_,
mainPhoneNumber = x$mainPhoneNumber %||% NA_character_,
registeredManagerAbsentDate = x$registeredManagerAbsentDate %||% NA_character_,
numberOfBeds = x$numberOfBeds %||% NA_integer_,
constituency = x$constituency %||% NA_character_,
localAuthority = x$localAuthority %||% NA_character_,
# Nested date fields (extract most recent if multiple)
lastInspection_date = extract_most_recent_date(x$lastInspection, "date"),
lastReport_publicationDate = extract_most_recent_date(x$lastReport, "publicationDate"),
# Array fields using helper function
locationTypes_type = extract_from_array(x$locationTypes, "type"),
regulatedActivities_name = extract_from_array(x$regulatedActivities, "name"),
regulatedActivities_code = extract_from_array(x$regulatedActivities, "code"),
regulatedActivities_contacts_personTitle = extract_contact_field(x$regulatedActivities, "personTitle"),
regulatedActivities_contacts_personGivenName = extract_contact_field(x$regulatedActivities, "personGivenName"),
regulatedActivities_contacts_personFamilyName = extract_contact_field(x$regulatedActivities, "personFamilyName"),
regulatedActivities_contacts_personRoles = extract_contact_field(x$regulatedActivities, "personRoles"),
gacServiceTypes_name = extract_from_array(x$gacServiceTypes, "name"),
gacServiceTypes_description = extract_from_array(x$gacServiceTypes, "description"),
specialisms_name = extract_from_array(x$specialisms, "name"),
inspectionCategories = extract_inspection_categories(x$inspectionCategories),
# Current ratings - detailed overall ratings
currentRatings_overall_organisationId = safe_extract(x, "currentRatings", "overall", "organisationId"),
currentRatings_overall_rating = safe_extract(x, "currentRatings", "overall", "rating"),
currentRatings_overall_reportDate = safe_extract(x, "currentRatings", "overall", "reportDate"),
currentRatings_overall_reportLinkId = safe_extract(x, "currentRatings", "overall", "reportLinkId"),
# Current ratings - useOfResources
currentRatings_overall_useOfResources_organisationId = safe_extract(x, "currentRatings", "overall", "useOfResources", "organisationId"),
currentRatings_overall_useOfResources_useOfResourcesRating = safe_extract(x, "currentRatings", "overall", "useOfResources", "useOfResourcesRating"),
currentRatings_overall_useOfResources_combinedQualityRating = safe_extract(x, "currentRatings", "overall", "useOfResources", "combinedQualityRating"),
currentRatings_overall_useOfResources_reportDate = safe_extract(x, "currentRatings", "overall", "useOfResources", "reportDate"),
currentRatings_overall_useOfResources_reportLinkId = safe_extract(x, "currentRatings", "overall", "useOfResources", "reportLinkId"),
# Current ratings - keyQuestionRatings as nested dataframe
currentRatings_keyQuestionRatings = extract_key_question_ratings(x$currentRatings$overall),
# Reports - most recent report only
reports_linkId = most_recent_report$linkId,
reports_reportDate = most_recent_report$reportDate,
reports_firstVisitDate = most_recent_report$firstVisitDate,
reports_reportUri = most_recent_report$reportUri,
reports_reportType = most_recent_report$reportType,
reports_relatedDocuments = extract_related_documents(most_recent_report$relatedDocuments),
# Unpublished reports
unpublishedReports_firstVisitDate = extract_unpublished_reports_first_visit(x$unpublishedReports),
# Provider inspection areas
providerInspectionAreas_inspectionAreaId = extract_provider_inspection_field(x$providerInspectionAreas, "inspectionAreaId"),
providerInspectionAreas_reports_inspectionId = extract_provider_inspection_field(x$providerInspectionAreas, "inspectionId"),
providerInspectionAreas_reports_reportLinkId = extract_provider_inspection_field(x$providerInspectionAreas, "reportLinkId"),
providerInspectionAreas_reports_providerId = extract_provider_inspection_field(x$providerInspectionAreas, "providerId"),
providerInspectionAreas_reports_locationId = extract_provider_inspection_field(x$providerInspectionAreas, "locationId")
)
}
#' Build CQC Location Dataset from Cached JSON Files
#'
#' @param package_name Name of the package/app cache directory (default: "location_ids")
#' @param dataset_name Name for the dataset (default: "location_df")
#' @param data_folder Path to the data folder (default: "data")
#' @return Invisibly returns the built dataset
#' @export
build_location_df <- function(package_name = "location_ids", dataset_name = "location_df", data_folder = "data") {
# Get the system cache directory
base_cache_dir <- tools::R_user_dir(package_name, "cache")
if (!dir.exists(base_cache_dir)) {
stop("Cache directory not found: ", base_cache_dir,
"\nPlease run cache_location_ids() and cache_location_jsons() first.")
}
# Find most recent location_information folder
subdirs <- list.dirs(base_cache_dir, full.names = TRUE, recursive = FALSE)
location_info_folders <- subdirs[grepl("location_information_", basename(subdirs))]
if (length(location_info_folders) == 0) {
stop("No location_information folders found in cache directory: ", base_cache_dir,
"\nPlease run cache_location_ids() first.")
}
most_recent_folder <- sort(location_info_folders, decreasing = TRUE)[1]
message("Using folder: ", basename(most_recent_folder))
# Look for JSON files in the location_jsons subfolder
json_subfolders <- list.dirs(most_recent_folder, full.names = TRUE, recursive = FALSE)
json_subfolder <- json_subfolders[grepl("location_jsons_", basename(json_subfolders))]
if (length(json_subfolder) == 0) {
stop("No location_jsons folder found in: ", most_recent_folder,
"\nPlease run cache_location_jsons() first.")
}
# Get all JSON files
json_files <- list.files(json_subfolder[1], pattern = "^location_.*\\.json$", full.names = TRUE, recursive = TRUE)
if (length(json_files) == 0) {
stop("No location JSON files found in: ", json_subfolder[1])
}
# Extract date from folder name
folder_name <- basename(most_recent_folder)
date_extracted <- stringr::str_extract(folder_name, "\\d{4}-\\d{2}-\\d{2}") %||% folder_name
message("Processing ", length(json_files), " files from ", folder_name)
# Process all files with progress
results_list <- vector("list", length(json_files))
for (i in seq_along(json_files)) {
file <- json_files[i]
# Show progress for each file
cat("\rProcessed", i, "of", length(json_files), "files")
flush.console()
tryCatch({
row_data <- extract_location_row(file)
row_data$folder_date <- date_extracted
row_data$source_file <- basename(file)
results_list[[i]] <- row_data
}, error = function(e) {
cat("\nError processing", basename(file), ":", e$message, "\n")
results_list[[i]] <- NULL
})
}
# Final progress update
cat("\rProcessed", length(json_files), "of", length(json_files), "files\n")
# Filter out NULL results and combine
valid_results <- Filter(Negate(is.null), results_list)
if (length(valid_results) == 0) {
stop("No valid results found. Check that extract_location_row() function is loaded and working.")
}
dataset <- dplyr::bind_rows(valid_results)
# Only reorder columns if they exist
if ("folder_date" %in% names(dataset) && "source_file" %in% names(dataset)) {
dataset <- dataset %>% dplyr::select(folder_date, source_file, everything())
}
# Save dataset
if (!dir.exists(data_folder)) dir.create(data_folder, recursive = TRUE)
rda_file_path <- file.path(data_folder, paste0(dataset_name, ".rda"))
assign(dataset_name, dataset)
save(list = dataset_name, file = rda_file_path, compress = "bzip2")
message("Saved ", nrow(dataset), " rows to ", rda_file_path)
# Display cache location info
message("Data source: ", json_subfolder[1])
invisible(dataset)
}
build_location_df()
#' #-------------------------------------------------------------------------------
#'
#' #' Get Location Info from Package Data for Specified IDs
#' #'
#' #' Given a vector of raw location IDs (with or without the "location_" prefix), this function
#' #' retrieves the corresponding rows from the pre-built `location_df` dataset
#' #' stored in the package's `data/location_df.rda` file. It matches on the numeric ID portion only.
#' #'
#' #' @param location_ids A character vector of raw location IDs (e.g., c("1-104456550", "1-104514560")
#' #'                     or c("location_1-104456550")).
#' #' @return A tibble containing location data for the specified IDs.
#' #' @importFrom dplyr filter
#' #' @importFrom tibble as_tibble
#' #' @export
#' get_location_info <- function(location_ids = NULL) {
#'   # Normalize input: strip any 'location_' prefix from IDs
#'   raw_ids <- vapply(location_ids, function(id) {
#'     sub("^location_", "", id)
#'   }, character(1))
#'
#'   # Locate the RDA file in the installed package or the local 'data/' directory
#'   rda_installed <- system.file("data", "location_df.rda", package = "cqc")
#'   if (nzchar(rda_installed) && file.exists(rda_installed)) {
#'     load(rda_installed, envir = environment())
#'   } else {
#'     local_rda <- file.path("data", "location_df.rda")
#'     if (file.exists(local_rda)) {
#'       load(local_rda, envir = environment())
#'     } else {
#'       stop("Could not find 'location_df.rda' in the installed 'cqc' package or the local 'data/' directory.")
#'     }
#'   }
#'
#'   # If the RDA loaded an object named 'combined_df', rename it for consistency
#'   if (!exists("location_df", envir = environment()) && exists("combined_df", envir = environment())) {
#'     location_df <- get("combined_df", envir = environment())
#'   }
#'
#'   if (!exists("location_df", envir = environment())) {
#'     stop("'location_df' not loaded: check that the RDA contains an object named 'location_df' or 'combined_df'.")
#'   }
#'
#'   # Filter by matching the numeric ID portion of the 'locationId' column
#'   if (is.null(location_ids)) {
#'     result <- location_df
#'   } else {
#'     result <- dplyr::filter(
#'       location_df,
#'       sub("^location_", "", locationId) %in% raw_ids
#'     )
#'   }
#'   missing_ids <- setdiff(raw_ids, result$locationId)
#'   num_missing_ids <- length(missing_ids)
#'
#'   if (num_missing_ids > 0) {
#'     warning(
#'       "The following IDs were not found.\n",
#'       paste(missing_ids, collapse = "\n"),
#'       ".\nTotal missing IDs: ", num_missing_ids
#'     )
#'   }
#'
#'   if (nrow(result) == 0) {
#'     stop(
#'       "No location data found for IDs: ",
#'       paste(raw_ids, collapse = ", ")
#'     )
#'   }
#'
#'   tibble::as_tibble(result)
#' }
